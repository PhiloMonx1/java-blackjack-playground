# 블랙잭

## 기능 요구 사항
블랙잭 게임을 변형한 프로그램을 구현한다. 블랙잭 게임은 딜러와 플레이어 중 카드의 합이 21 또는 21에 가장 가까운 숫자를 가지는 쪽이 이기는 게임이다.

- <b>플레이어는 게임을 시작할 때 배팅 금액을 정해야 한다.</b>
- 카드의 숫자 계산은 카드 숫자를 기본으로 하며, 예외로 Ace는 1 또는 11로 계산할 수 있으며, King, Queen, Jack은 각각 10으로 계산한다.
- 게임을 시작하면 플레이어는 두 장의 카드를 지급 받으며, 두 장의 카드 숫자를 합쳐 21을 초과하지 않으면서 21에 가깝게 만들면 이긴다. 21을 넘지 않을 경우 원한다면 얼마든지 카드를 계속 뽑을 수 있다. 단, 카드를 추가로 뽑아 21을 초과할 경우 배팅 금액을 모두 잃게 된다.
- 처음 두 장의 카드 합이 21일 경우 블랙잭이 되면 베팅 금액의 1.5 배를 딜러에게 받는다. 딜러와 플레이어가 모두 동시에 블랙잭인 경우 플레이어는 베팅한 금액을 돌려받는다.
- 딜러는 처음에 받은 2장의 합계가 16이하이면 반드시 1장의 카드를 추가로 받아야 하고, 17점 이상이면 추가로 받을 수 없다. 딜러가 21을 초과하면 그 시점까지 남아 있던 플레이어들은 가지고 있는 패에 상관 없이 승리해 베팅 금액을 받는다.

## 실행 결과

```
게임에 참여할 사람의 이름을 입력하세요.(쉼표 기준으로 분리)
pobi,jason

pobi의 배팅 금액은?
10000

jason의 배팅 금액은?
20000

딜러와 pobi, jason에게 2장의 나누었습니다.
딜러: 3다이아몬드
pobi카드: 2하트, 8스페이드
jason카드: 7클로버, K스페이드

pobi는 한장의 카드를 더 받겠습니까?(예는 y, 아니오는 n)
y
pobi카드: 2하트, 8스페이드, A클로버
pobi는 한장의 카드를 더 받겠습니까?(예는 y, 아니오는 n)
n
jason은 한장의 카드를 더 받겠습니까?(예는 y, 아니오는 n)
n
jason카드: 7클로버, K스페이드

딜러는 16이하라 한장의 카드를 더 받았습니다.

딜러 카드: 3다이아몬드, 9클로버, 8다이아몬드 - 결과: 20
pobi카드: 2하트, 8스페이드, A클로버 - 결과: 21
jason카드: 7클로버, K스페이드 - 결과: 17

## 최종 수익
딜러: 10000
pobi: 10000 
jason: -20000
```

## 프로그래밍 요구 사항

- 자바 코드 컨벤션을 지키면서 프로그래밍한다.
    - 기본적으로 Google Java Style Guide을 원칙으로 한다.
    - 단, 들여쓰기는 '2 spaces'가 아닌 '4 spaces'로 한다.
- indent(인덴트, 들여쓰기) depth를 2를 넘지 않도록 구현한다. 1까지만 허용한다.
    - 예를 들어 while문 안에 if문이 있으면 들여쓰기는 2이다.
    - 힌트: indent(인덴트, 들여쓰기) depth를 줄이는 좋은 방법은 함수(또는 메서드)를 분리하면 된다.
- 3항 연산자를 쓰지 않는다.
- else 예약어를 쓰지 않는다.
    - else 예약어를 쓰지 말라고 하니 switch/case로 구현하는 경우가 있는데 switch/case도 허용하지 않는다.
    - 힌트: if문에서 값을 반환하는 방식으로 구현하면 else 예약어를 사용하지 않아도 된다.
- 모든 기능을 TDD로 구현해 단위 테스트가 존재해야 한다. 단, UI(System.out, System.in) 로직은 제외
    - 핵심 로직을 구현하는 코드와 UI를 담당하는 로직을 구분한다.
    - UI 로직을 InputView, ResultView와 같은 클래스를 추가해 분리한다.
- 함수(또는 메서드)의 길이가 10라인을 넘어가지 않도록 구현한다.
    - 함수(또는 메소드)가 한 가지 일만 하도록 최대한 작게 만들어라.
- 배열 대신 컬렉션을 사용한다.
- 모든 원시 값과 문자열을 포장한다
- 줄여 쓰지 않는다(축약 금지).
- 일급 컬렉션을 쓴다.
- 모든 엔티티를 작게 유지한다.
- 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
- 딜러와 플레이어에서 발생하는 중복 코드를 제거해야 한다.

## 기능 목록 및 commit 로그 요구사항
- 기능을 구현하기 전에 README.md 파일에 구현할 기능 목록을 정리해 추가한다.
    - git의 commit 단위는 앞 단계에서 README.md 파일에 정리한 기능 목록 단위로 추가한다.
    - 참고문서: AngularJS Commit Message Conventions

#### AngularJS Commit Message Conventions 중
- commit message 종류를 다음과 같이 구분
```
feat (feature)
fix (bug fix)
docs (documentation)
style (formatting, missing semi colons, …)
refactor
test (when adding missing tests)
chore (maintain)
```
---
## 구현

오버엔지니어링으로 인해 방향성을 잃고 블랙잭을 처음부터 다시 설계하게 되었다. <br>
목표한 시간보다 더 오래 걸리고 있는 만큼 최대한 지금까지 고민한 내용을 살려서 구현을 하고 싶었지만. <br>
피드백 강의에서 말하는대로 내가 작성한 코드를 아까워하지 않고, 처음부터 하는 것이 시간적으로 더 낫다는 판단이 들었다. <br>
처음 설계가 가장 중요하다. 요구사항을 명확하게 이해하고, 요구사항만을 만족하는 것으로만 설계하고자 한다. <br>
그러기 위해 요구사항 먼저 다시 정리하고, Todo를 보다 자세히 작성하려 한다.
<details>
<summary>시행착오</summary>

### 설계 01

1. 카드는 어떻게 해야 할까? 문양이 있고 A, 2~10 , K,Q,J 가 있다. 총 52장 이지만 규칙이 있고, 정해져 있다. 어떻게 구현해야 할까
2. 동일 게임 내에 중복된 카드는 존재할 수 없다. & 카드는 계산 되어야 한다.
3. 플레이어와 딜러는 각각 다른 동작을 한다. (공통 클래스를 상속받을 수 있다)
4. 배팅 금액은 게임 내에서만 유효한 인스턴스이므로 현 요구사항에서는 저장되거나 관리될 필요가 없다 (현재 상태로는 배팅 금액은 승,패에 대한 View에 가깝다.)
5. 딜러의 두 번째 카드는 공개되지 않는다(?)
6. 은/는 조사에 대한 처리를 해야 한다(?)

### 설계 02

1. 어떻게 분리할 것인가
- Model
  - 카드
  - 플레이어
  - 딜러
  - 돈 (요구사항 상 별도 Model로 분리할 필요가 없지만, 추후 개발의 확장을 위해 분리)
- View
  - input view = 게임에 참여할 사람의 이름을 입력하세요.(쉼표 기준으로 분리) & 배팅 금액은? & 카드를 더 받겠습니까?
  - output view = 카드 결과, 최종 수익
- Controller

### 설계 03
#### 카드
1. 카드는 Set으로 관리해야 한다. > 카드 객체가 동일한지 판단하는 함수가 필요.
2. 카드를 뽑는 로직이 필요하다.
3. 현재 카드 Set을 기반으로 계산을 하는 로직이 필요하다. (각 카드 객체는 자신의 숫자 값을 리턴해야 한다. A의 경우 1, 11을 리턴....)
4. 카드 인터페이스가 있고, 블랙잭 카드가 상속 하는 것은 어떨까
5. 람다를 통해 익명 클래스를 작성해서 카드의 값을 결정하도록 하는 것은 어떨까
6. 블랙잭 카드는 자기 자신의 정보를 리턴하는 함수를 가진다. ('2스페이드', 'K하트' 등으로 바꿔서 리턴.)
7. 트럼프 문양 Enum이 있다.
1. 트럼프 문양 Enum은 숫자 or A,J,Q,K를 가진다. (이때 1, 11, 12, 13으로 가지도록 한다.)

#### 플레이어
1. 플레이어는 딜러와 플레이어로 나뉜다.
2. 필드 변수로 카드 Set을 가진다.
3. 필드 변수로 Money를 가진다.
4. 플레이어는 카드를 뽑는 동작을 가진다.
5. 플레이어는 카드의 getter를 가진다.

#### blackjack 게임 유틸
1. 카드 리스트를 받아서 전체 값을 계산하는 로직,
2. 카드 값을 기준으로 boolean 형태로 리턴하는 람다 함수.

### 구현 일지

#### 카드의 합산 값
블랙잭 게임에서는 카드의 합산 값이 중요한 역할을 수행한다.
1. A의 경우 <b>카드 합산 값이 10 이하일 경우</b> 1이 아닌 11로 계산된다.
- 만약 A하트, 7하트, 4하트 가 순서대로 나온다고 해도, 기존의 A하트는 11이 아닌 1로 계산되어 게임오버가 되지 않는다.
- 이미 합산한 값을 저장해서 사용하는 것이 아닌, 새로운 카드를 받을 때마다 새로운 합산 값을 다시 계산해야 한다.
2. 딜러의 경우 <b>카드 합산 값이 16이하 일 경우</b> 카드를 한 장 더 받는다.
3. 플레이어(딜러 포함)의 경우 <b>카드 합산 값이 21을 초과할 경우</b> 즉시 게임을 패배한다.

즉, 카드 합산 값은 블랙잭 게임 내에서 중복된 코드이 발생할 수 있는 여지를 준다.
이를 람다식으로 표현해서 중복을 제거하는 방향으로 구현 하고자 한다.

#### 플레이어
플레이어는 딜러와 플레이어가 있으며, 블랙잭 플레이어의 경우 [BlackJack.java](model%2FBlackJack.java) 클래스에 의존적이기 때문에 별도 클래스로 분리되어야 한다.

블랙잭 플레이어는 카드의 합산 값을 가지고 있어야 한다(?)
- 새로운 카드가 추가되었을 때 기존 값을 더하는 방식은 A의 동작 때문에 더 복잡해질 수 있다.
- 블랙잭 플레이어가 카드의 합산 값을 인스턴스 변수로 가지고 있을 필요가 있는가?

- A
  - 플레이어와 딜러를 Gamer 추상 클래스를 상속하도록 만든 후 BlackJackCardGameAble 인터페이스를 상속하게 한다.
  - BlackJackCardGameAble는 CardGameAble 인터페이스를 상속하게 만든다.

- B
  - 플레이어와 딜러를 CardGamer 추상 클래스를 상속하도록 만든 후 BlackJackAble 인터페이스를 상속하게 한다.<br>
  - CardGamer는 Gamer 추상 클래스를 상속하게 만든다.

> 상속을 사용해서 player를 구현하고 싶었기에 이 시점에서 고민을 많이 했다.
> 그러나 아직 인터페이스로 시작해야 할지 추상클래스로 해야할지 고민이 되기도 했고,
> 무엇보다 플레이어와 딜러의 공통점과 차이점을 설계하는 것도 명확하게 그려지지 않았다.
> 우선은 플레이어와 딜러를 구현하면서 중복되는 코드를 리팩토링하는 방식으로 구현해야겠다.

---
#### 일급컬렉션
일급 컬렉션을 학습하면서 든 생각은, 일급컬렉션은 배열이나 컬렉션 형태의 래퍼클래스라는 것이었다.
그런데 직접 구현을 하려다보니 많은 고민이 생겼다.
1. 일급 컬렉션은 불변성을 보장해야 하는가?
- 만약 불변해야 하는 컬렉션이면 카드를 받았을 때 add가 아닌 새로운 컬렉션을 다시 부여해야 하는 것인가?
- final은 재할당이 불가한 것이지 add, remove를 막아주는 것이 아니다.
2. 일급컬렉션은 add(), remove()를 수행하는 메서드를 가질 수 있는가?
3. 생성자 초기화는 어떻게 해야 하는가?
- 외부에서 생성자를 생성하도록 하는게 맞는가?
4. DI로 내부 주입을 한다면?
1. Gamer를 생성할 때 Gamer의 이름만 입력하면 Gamer가 생성되고, 비어있는 Cards가 필드로 생성
2. Cards는 외부에서 생성할 수 없으며, Gamer에서 Cards를 통제 (add에 대한 부분 통제)
```java
public class Gamer {

	private final GamerName name;
	private final Cards cards;

	public Gamer(String name) {
		this.name = new GamerName(name);
		this.cards = new Cards();
	}
	
    public String getName() {
      return name.getName();
    }
}
```
```java
class GamerName {

	private final String name;

	GamerName(String name) {
		if (name == null || name.isEmpty()) {
			throw new IllegalArgumentException("이름은 빈값으로 설정할 수 없습니다.");
		}
		this.name = name;
	}

	String getName() {
		return name;
	}
}
```
> `GamerName`의 경우 생성자의 접근제어자를 Default로 설정해서 패키지가 다른 경우 접근하지 못하도록 함.
> `Gamer` 생성 시 `this.name = new GamerName(name);`를 통해 DI로 처리하고 있음.
> 이와 같은 방법으로 Cards() 역시 외부에서 접근하지 못하도록 하는 것은 어떨까?

`GamerName` 은 `Gamer` 없이 존재할 수 없다. 실체가 없는 이름은 존재하지 않기 때문이다. (클래스를 실제와 연결한다고 했을 떄)<br>
그러나 `Cards` 는 `Gamer`가 없이도 존재할 수 있지 않을까? ex) 카드 덱은 플레이어나 딜러의 소유가 아닌 중앙 관리 개념이다.<br>
즉 실제와 같다고 가정했을 때 `Cards`가 `Gamer`에게 귀속되고, DI로 처리되는 것이 합당한지에 대한 물음이 생긴다.<br>
`Cards`는 [TrumpCard.java](model%2FTrumpCard.java) 묶음을 관리하는 객체로서의 역할을 수행해야 한다.<br>

#### 오버엔지니어링
설계를 하면서 진도가 나가지 않고 계속해서 반복되는 고민과 철회가 연속되었다.<br>
이런 고민을 했다
> `Gamer` 라는 객체가 있다. 해당 객체는 블랙잭을 플레이한다. 그런데 블랙잭이 아닌 다른 카드 게임을 플레이 할 수도 있지 않을까?
> 그럼 `Gamer` 객체에 인터페이스로 `BlackJackAlble' 상속하도록 하는 것은 어떨까?
> 그런데 만약 카드 게임이 아닌 게임을 할 수도 있다면 어떨까? `Gamer`가 `CardGamer`를 상속해야 할까?
> 플레이 하는 카드가 트럼프 카드가 아니면 어떨까?

#### YAGNI 원칙
피드백 강의에서 미래를 생각하면서 오버엔지니어링을 하는 것을 주의하라는 언급이 있었었다. <br>
YAGNI 원칙은 (You aren't gonna need it) 의 약어로 필요한 일만 하라는 의미이다. <br>
블랙잭을 설계하면서 너무 많은 욕심을 냈었다. 그러면서 설계가 복잡해지고, 코드를 적는 시간보다 설계를 고민하고 철회하는 시간이 더 많아졌다. <br>
좀 더 단순하게 생각할 필요가 있다. 나는 현재 도메인 지식과 경험이 부족한 상태로 지금 주어진 요구사항에 충실하는 일로 돌아가는 것이 시급하다. <br>
작업 내역을 리셋하고 처음부터 다시 하기로 했다.
</details>

### 요구사항 분석
플레이어, 딜러, 카드가 있다.
1. `플레이어`는 이름, 배팅금액, 카드 리스트를 가진다.
   - 플레이어 이름, 배팅금액은 input을 통해 결정된다.
   - 최소 생성시 2장의 카드를 받는다.
   - 플레이어 카드는 랜덤으로 결정된다.
   - 카드 값의 합이 21 미만일 경우 새로운 카드를 받을 수 있다.
     - 카드 값의 합이 21을 초과할 경우 즉시 패배한다.
2. `딜러`는 카드 리스트를 가진다.
   - 최초 생성시 2장의 카드를 받는다. 
     - 이 때 첫번째 카드는 공개하지 않는다.
   - 카드 값의 합이 16 이하일 경우 한 장을 추가로 뽑는다.
   - 카드 값의 합이 21 초과일 경우 남아 있는 즉시 패배한다.
     - 이때까지 남아있는 플레이어는 즉시 승리한다.
3. `카드`는 조커를 제외한 트럼프 카드 52장으로 구성된다.
   - 2~10 카드는 각 카드 숫자와 동일한 값을 가진다, 
   - A는 1 or 11 중 플레이어에게 유리한 방향으로 계산이 가능하다.
   - K,Q,J는 10으로 계산한다.
4. `컴퓨터`는 카드의 합을 계산하고 승자를 리턴하는 로직을 가진다.
   - 람다를 통해 11, 16, 21 등의 숫자를 기준으로 각각 다른 boolean 값을 리턴한다.
     - `플레이어 & 딜러` 카드 합이 21을 초과할 경우 -> 버스트
     - `딜러` 카드 합이 16 이하일 경우 -> 한 장 더 뽑기
     - `플레이어 & 딜러` 카드 합이 10이하 일 경우 -> A는 11로 계산
     - `플레이어 & 딜러` 정확히 21일 경우 & 카드 갯수가 2개일 경우 -> 블랙잭
   - 람다를 통해 승자를 리턴하고, 배팅금을 계산하는 로직을 가진다.
     - `플레이어` 블랙잭인 경우 -> 배팅 금액의 1.5 배를 딜러에게 받는다.
     - `플레이어` & `딜러` -> 배팅 금액을 돌려 받는다.
     - 블랙잭이 없는 경우 -> 카드 합을 비교하여 큰 쪽이 승리한다.
     - 패배한 경우 배팅금을 잃는다. 승리한 경우 패배자가 잃은 배팅금을 가진다.
5. View
  - input view
    - 게임에 참여할 사람의 이름을 입력하세요.(쉼표 기준으로 분리)
    - {Player}의 배팅 금액은?
    - {Player}는 한장의 카드를 더 받겠습니까?(예는 y, 아니오는 n)
  - output view
    - 딜러와 {Player[]}에게 2장의 나누었습니다.
    - {Player}"카드: "{Card}, {Card}
    - {Dealer}"카드: "{Card}
    - "딜러는 16이하라 한장의 카드를 더 받았습니다."
    - "- 결과: "{int}
    - 최종 수익